```
requestAnimationFrame
        │
    [Ticker._tick()]
        │
    ├─ ⏱️ Compute elapsed time
    ├─ 🔁 Call user listeners (e.g. sprite.onRender)
    ├─ ✂️ Cull display objects (可选优化)
    ├─ 🔄 Update world transforms
    └─ 🖼️ Render stage
            ├─ 🔍 Traverse display list
            ├─ 📤 Upload data to GPU
            └─ 🎨 Draw to screen
```

```
requestAnimationFrame
        │
    [Ticker._tick()]
        │
    ├─ 计算经过的时间
    ├─ 调用用户监听函数
    │   └─ sprite.onRender
    ├─ 剔除显示对象（如果启用）
    ├─ 更新世界变换矩阵
    └─ 渲染舞台
            ├─ 遍历显示列表
            ├─ 上传数据到 GPU
            └─ 执行绘制
```

逐步翻译说明：
✅ requestAnimationFrame
浏览器提供的动画帧函数，每秒最多调用约 60 次。

是所有动画渲染的启动入口。

✅ Ticker.\_tick()
PixiJS 的 ticker 是动画主循环的封装，它每帧会调用 \_tick() 方法，依次执行以下步骤：

1. 计算经过的时间
   获取当前帧与上一帧之间的时间差（deltaTime），用于控制动画进度、速度等。

2. 调用用户监听函数
   执行用户注册的监听器函数，如：ticker.add(sprite.onRender);通常你会在 onRender 中执行动画逻辑、位置移动、缩放、旋转等。

3. 剔除显示对象（如果启用）
   如果启用了视图剔除优化，会跳过屏幕外或不可见的对象，以提升性能。

4. 更新世界变换矩阵
   更新所有显示对象的世界变换（worldTransform），例如位置、旋转、缩放等。子对象会继承父容器的变换。

5. 渲染舞台
   这是实际将图形绘制到画布上的过程，包含：

├─ 遍历显示列表
遍历所有容器、精灵、图形等可显示对象，准备绘制数据。

├─ 上传数据到 GPU
将纹理、顶点、颜色等数据上传到 GPU（显卡）中。

└─ 执行绘制
通过 WebGL 发起绘制指令，把最终画面渲染在 <canvas> 上。
