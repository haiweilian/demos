## MyISAM 难实现行锁的原因

> 关于锁的问题，MyISAM 通过索引命中，通过指针锁住了一行数据，后续的 sql 通过其他索引，不也同样根据指针指向了同一行数据，为什么就锁不住呢？

不行的，行锁是基于索引键上锁的，前面我跟你说的锁行记录，其实是锁了聚簇索引树的叶子节点（因为 InnoDB 的行数据和索引数据存在一个文件中），但如果 MyISAM 引擎就不行，因为所有表数据文件全部放在一个数据文件中（MYD），这时无法很好的区分每行数据。

你可能对于我说的无法很好的区分行数据不太理解，就比如我举个例子：

一张 MyISAM 引擎的表，基于某个索引字段查找数据，然后找到一个索引键，然后根据索引键中记录的磁盘地址，去 MYD 数据文件中找到了一条具体的行数据，这条数据记作 ID=888，然后假设对其加上了一个行锁。

此时当另外一个事务，基于另外一个索引字段，也定位到了这条 ID=888 的数据，然后可以看到上面有行锁，就会放弃加锁，从而阻塞等待。

我想你要表达的应该是上述这个加锁过程对嘛？这样的确可以实现行锁，但因为 MyISAM 引擎中的索引数据，记录的是数据的磁盘地址，假设 ID=888 的这条数据，磁盘地址为 0x8867，而此时我等第一个事务上锁之后，将它前面的 ID=887 的数据删了，这时会发生什么情况？
在这个时候 ID=888 这条数据就会向前挪动（不一定实时挪动，会有定期整理），从而导致行数据的磁盘地址发生变化，这时问题来了，前面锁的是 0x8867 这个指针指向的数据，而现在因为删了 ID=887 的数据，ID=888 的数据可能地址变成了 0x6667，那此时第二个事务加锁时，发现 0x6667 这个地址上没有锁，就会对其加锁。

此时你看，ID=888 这条数据，它的新老地址上都会产生一个行锁，一条数据产生了两个行锁，而且这个问题在 MyISAM 引擎出现增删改操作时，都会产生。

所以 MyISAM 引擎不实现行锁的根本原因，就在于此，不是不想，而是做不到，因为索引数据和表数据是分开的，所以无法真正锁住一行数据，因为锁定一行数据后，只要它前面的数据发生写操作，它的地址就有可能改变，无法很好的去维护行锁。

而 InnoDB 实现行锁的根本原因，这是在于它的索引数据和表数据是在一起的，次级索引中，存的是聚簇索引键，基于这种回表的形式去加锁，这时不管 ID=888 前面的数据怎么变，就算全删掉也好，依旧不会影响 ID=888 这条数据上的行锁。

不知道我这样跟你去说明，你是否能够真正理解为什么 MyISAM 引擎不能实现行锁的原因哈[送心]
